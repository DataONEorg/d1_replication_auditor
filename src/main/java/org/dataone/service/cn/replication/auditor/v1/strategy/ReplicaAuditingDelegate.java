package org.dataone.service.cn.replication.auditor.v1.strategy;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;
import org.dataone.client.v1.MNode;
import org.dataone.client.v1.itk.D1Client;
import org.dataone.cn.hazelcast.HazelcastClientFactory;
import org.dataone.cn.log.AuditEvent;
import org.dataone.cn.log.AuditLogClientFactory;
import org.dataone.cn.log.AuditLogEntry;
import org.dataone.configuration.Settings;
import org.dataone.service.cn.replication.ReplicationFactory;
import org.dataone.service.cn.replication.ReplicationService;
import org.dataone.service.exceptions.BaseException;
import org.dataone.service.exceptions.InvalidRequest;
import org.dataone.service.exceptions.InvalidToken;
import org.dataone.service.exceptions.NotAuthorized;
import org.dataone.service.exceptions.NotFound;
import org.dataone.service.exceptions.NotImplemented;
import org.dataone.service.exceptions.ServiceFailure;
import org.dataone.service.types.v1.Checksum;
import org.dataone.service.types.v1.Identifier;
import org.dataone.service.types.v1.Node;
import org.dataone.service.types.v1.NodeReference;
import org.dataone.service.types.v1.NodeType;
import org.dataone.service.types.v1.Replica;
import org.dataone.service.types.v1.ReplicationStatus;
import org.dataone.service.types.v1.SystemMetadata;

import com.hazelcast.core.IMap;

/**
 * Replication Auditing Delegate class - encapulsates common replication auditing logic
 * used across the different replica auditing strategies.
 * 
 * @author sroseboo
 */
public class ReplicaAuditingDelegate {

    public static Logger log = Logger.getLogger(ReplicaAuditingDelegate.class);

    private static final String cnRouterId = Settings.getConfiguration().getString(
            "cn.router.nodeId", "urn:node:CN");

    private ReplicationService replicationService;
    private IMap<NodeReference, Node> hzNodes;
    private Map<NodeReference, MNode> mnMap = new HashMap<NodeReference, MNode>();

    public ReplicaAuditingDelegate() {
        replicationService = ReplicationFactory.getReplicationService();
        hzNodes = HazelcastClientFactory.getProcessingClient().getMap("hzNodes");
    }

    /**
     * Retrieves system meta data from CN cluster and logs appropriate
     * audit log message if not able to retrieve.  First removes any
     * existing log message that would be generated by previous error
     * in this method.
     * 
     * @param pid
     * @return
     */
    protected SystemMetadata getSystemMetadata(Identifier pid) {

        AuditLogClientFactory.getAuditLogClient().removeReplicaAuditEvent(
                new AuditLogEntry(pid.getValue(), cnRouterId, AuditEvent.REPLICA_AUDIT_FAILED,
                        null, null));
        SystemMetadata sysMeta = null;
        try {
            sysMeta = replicationService.getSystemMetadata(pid);
        } catch (NotFound e) {
            log.error("Could not find system meta for pid: " + pid.getValue());
        }
        if (sysMeta == null) {
            log.error("Cannot get system metadata from CN for pid: " + pid
                    + ".  Could not replicas for pid: " + pid + "");
            AuditLogEntry logEntry = new AuditLogEntry(pid.getValue(), cnRouterId,
                    AuditEvent.REPLICA_AUDIT_FAILED,
                    "Unable to audit replica.  Could not retrieve system metadata for pid: "
                            + pid.getValue() + " from the CN cluster for replication auditing.");
            AuditLogClientFactory.getAuditLogClient().logAuditEvent(logEntry);
        }
        return sysMeta;
    }

    protected MNode getMNode(NodeReference nodeRef) {
        if (!mnMap.containsKey(nodeRef)) {
            MNode mn = null;
            try {
                mn = D1Client.getMN(nodeRef);
            } catch (ServiceFailure e1) {
                e1.printStackTrace();
            }
            if (mn != null) {
                try {
                    mn.ping();
                    mnMap.put(nodeRef, mn);
                } catch (BaseException e) {
                    log.error("Unable to ping MN: " + nodeRef.getValue(), e);
                }
            } else {
                log.error("Cannot get MN: " + nodeRef.getValue()
                        + " unable to verify replica information.");
            }
        }
        return mnMap.get(nodeRef);
    }

    protected void updateVerifiedReplica(Identifier pid, Replica replica) {
        replica.setReplicationStatus(ReplicationStatus.COMPLETED);
        replica.setReplicaVerified(this.calculateReplicaVerifiedDate());
        boolean success = replicationService.updateReplicationMetadata(pid, replica);
        if (!success) {
            log.error("Cannot update replica verified date  for pid: " + pid + " on CN");
        }
        AuditLogClientFactory.getAuditLogClient().removeReplicaAuditEvent(
                new AuditLogEntry(pid.getValue(), replica.getReplicaMemberNode().getValue(), null,
                        null, null));
    }

    protected void updateInvalidReplica(Identifier pid, Replica replica) {
        replica.setReplicationStatus(ReplicationStatus.INVALIDATED);
        replica.setReplicaVerified(this.calculateReplicaVerifiedDate());
        boolean success = replicationService.updateReplicationMetadata(pid, replica);
        if (!success) {
            log.error("Cannot update replica status to INVALID for pid: " + pid + " on MN: "
                    + replica.getReplicaMemberNode().getValue());
        }
    }

    protected Checksum getChecksumFromMN(Identifier pid, SystemMetadata sysMeta, MNode mn)
            throws NotFound, ServiceFailure, InvalidRequest, InvalidToken {
        Checksum checksum = null;
        for (int i = 0; i < 5; i++) {
            try {
                checksum = mn.getChecksum(pid, sysMeta.getChecksum().getAlgorithm());
                break;
            } catch (ServiceFailure e) {
                if (i >= 4) {
                    throw e;
                }
                // try again, no audit (skip)
            } catch (InvalidRequest e) {
                if (i >= 4) {
                    throw e;
                }
                // try again, no audit (skip)
            } catch (InvalidToken e) {
                if (i >= 4) {
                    throw e;
                }
                // try again, no audit (skip)
            } catch (NotAuthorized e) {
                // cannot audit, set to invalid
                checksum = new Checksum();
                break;
            } catch (NotImplemented e) {
                // cannot audit, set to invalid
                checksum = new Checksum();
                break;
            }
        }
        return checksum;
    }

    protected boolean isCNodeReplica(Replica replica) {
        boolean isCNodeReplica = false;
        if (replica != null && replica.getReplicaMemberNode() != null) {
            Node node = hzNodes.get(replica.getReplicaMemberNode());
            if (node != null && node.getType() != null) {
                isCNodeReplica = NodeType.CN.equals(node.getType());
            }
        }
        return isCNodeReplica;
    }

    protected Date calculateReplicaVerifiedDate() {
        return new Date(System.currentTimeMillis());
    }

    protected boolean isAuthoritativeMNReplica(SystemMetadata sysMeta, Replica replica) {
        return replica.getReplicaMemberNode().getValue()
                .equals(sysMeta.getAuthoritativeMemberNode().getValue());
    }

    protected String getCnRouterId() {
        return cnRouterId;
    }
}
